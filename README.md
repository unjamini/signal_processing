# Большая лабораторная работа по курсу "Обработка сигналов"

## Постановка задачи и требования к изображениям
На вход подаётся изображение чёрного параллелепипеда и фиолетовой рамки. Требуется установить, может ли параллелепипед пройти под рамкой, если перемещать его параллельным переносом, не отрывая от поверхности.

**Требования к фото:** 

- Вертикальные фото, разрешение камеры: не менее 10 Мп
- К фотографии не применялись фильтры
- Фон - светлый
- Все объекты целиком помещаются на изображении, при этом нет посторонних объектов
- Нет засвеченных областей
- Должна быть видна внутренняя часть арки (то есть фотографии сверху/совсем сбоку не подходят)

### Изначальные данные
[Собранный датасет](https://drive.google.com/drive/folders/1Jr4W6rxadaJREGK3urXD3iNPU_d2JivA?usp=sharing)

## Алгоритм
**Часть 1. Выделение значений признаков из изображения**
Сначала изображение конвертируется в ЧБ формат и бинаризуется c помощью порога по алгоритму Yen. (Шага с бинаризацией изначально в планах не было, но экспериментально я выявила, что для многих изображений последующая обработка получается эффективней после бинаризации. Эффективней в том плане, что находтся больше нужных прямях.)

Затем к изображению применяется фильтр Canny и после этого алгоритмом Хафа осуществляется поиск прямых. Затем из всех прямых выделяются наиболее похожие на вертикальные - те, у которых модуль угла наклона в радианах < 0.1, и горизонтальные - те, у которых модуль угла наклона в радианах > 0.9. Эти значения были подобраны вручную "на глаз".

С помощью набора найденных прямых я считаю следующие величины:
- число найденных вертикальных прямых на изображении
- число найденных горизонтальных прямых на изображении
- положение самой верхней из горизонтальных прямых
- максимальное расстояние между 2мя параллельными (с некоторым $\epsilon$) вертикальными прямыми

Затем я снова бинаризую изображение, но уже с помощью самого высокого из найденных порогов (из методов предлагаемых в *skimage.filters*). Таким образом я пытаюсь найти площадь черного прямоугольника - он по идее должен быть самым тёмным. На бинаризованном изображении снова нахожу прымые описанным выше способом и считаю следующие значение:
- площадь выделенной области после бинаризации
- угол наклона коробки (угол для максмального числа парраллельных горизонатльных прямых)
- максимальное расстояние между 2мя параллельными горизонтальными прямыми

***Пояснение к выделению фич:***
Описанные выше признаки придумывались и подбирались эмпирически из соображений вида "Если пар-пипед перекрывает обе боковые грани рамки, то он в неё точно не пролезет. В таком случае число найденных вертикальных прямых на фото должно быть меньше".

**Часть 2. Классификация**

Затем найденный массив данных используется для обучения kNN. Используется конфигурация с использованием значений 3-х ближайших соседей, из значения влияют на результат взвешенно - в зависимости от расстояния до точки.


**Неудавшиеся попытки**
Были предприняты попытки найти площадь пар-пипеда с помощью выделения с помощью карты гранц и с помощью метода водораздела. В первом случае это оказалось невозможным в связи с тем, что объект не единственный на фото, а во втором мне так и не удалось придумать хороший алгоритм для постановки маркеров областей.

## Запуск решения
По сути решение состоит из 2 основных шагов: выделение фич и обучение модели. Первый этап можно повторить с помощью кода в части **Предобработка данных** в выложенном jupyter notebook (подробные комментарии есть в ноутбуке). Если возможности скачать датасет с фотографиями нет, то можно воспользоваться сохранёнными датасетами *train_df.csv* и *test_df.csv*. Тогда можно сразу переходить к коду во второй половине ноутбука (начиная с импорта файлов).

## Результаты и примеры работы алгоритма
Рассмотрим примеры, на которых алгоритм отработал корректно. Это пример правильной классификации положения, при котором ответ *True*. Видно, что преобразованием Хафа найдено достаточно много прямых, поэтому все значения свойств для этого изображения были подсчитаны верно.

<p align="middle">
  <img src="/examples/pos-right.png" width="200" />
  <img src="/examples/pos-right-huff.png" width="200" /> 
</p>

Это пример правильной классификации положения, при котором ответ *False*. Видно, что преобразованием Хафа найдено небольшое количество прямых. Позднее мы заметим, что чем меньше прямых найдено на изображении, тем более алгоритм тяготеет к отрицательному ответу. Это было одно из предположений, которые я делала, когда вводила такой признак (логика простая: если коробка на переднем фоне прееркрывает рамку, и её прямые не выделяются -> коробка в рамку не пролезет).

<p align="middle">
  <img src="/examples/neg-right.png" width="200" />
  <img src="/examples/neg-right-huff.png" width="200" /> 
</p>

Теперь посмотрим на примеры, на которых алгоритм ошбается. Начнём с ошибок 1 рода.

<p align="middle">
  <img src="/examples/error.png" width="200" />
  <img src="/examples/error1-huff.png" width="200" /> 
</p>

<p align="middle">
  <img src="/examples/error1-ex2.png" width="200" />
  <img src="/examples/error1-ex2-huff.png" width="200" /> 
</p>

Заметим, что оба таких примера обладают таким свойством, что на них найдено мало прямых. Поэтому они и ошибочно классифицировались, как *False*.

Перейдём к ошибкам 2 рода.
<p align="middle">
  <img src="/examples/error2.png" width="200" />
  <img src="/examples/error2-huff.png" width="200" /> 
</p>

Такое изображение классифицировалось, как *True*. Предположительно это связано с недостаточным колчеством примеров с такого ракурса.

На тестовом датасете получается следующая *accuracy*: 0.615.
## Анализ результатов и предполагаемые способы решения проблем

После первого тестирования некоторые недстатки алгоритма сразу проявили себя.
Далеко не на всех изображениях алгоритм Хафа детектирует достаточное для анализа количество прямых. Это может быть связано со способом выделения границ, а может быть связано со спецификой изображений. Для того, чтобы решить эту проблему, я хочу попробовать:
- поэкспериментровать с параметрами и методами выделения границ
- попробовать заменить поиск прямых на поиск особых точек, чтобы использовать для анализа уже их

Также, стало понятно, что собранных данных недостаточно для обучения моделей для качественной классификации, поэтому я планирую расширить датасет разнообразными примерами.

Ещё один возможный способ улучшения качества классификации - поиск и конструирование новых признаков. 

Помимо всего этого, есть другой момент который я не учитываю - ситуации, когда горизонтальных/веритикальных прямых на изображении не нашлось вообще. В таком случае сейчас значение соответствующего признака заполняется некоторым дефолтным образом (как правило 0) и знание (вероятно, ценное для классификации) об отсутствии этого значения теряется. Возможно, ест смысл ввести отдельные бинарные фичи для таких ситуаций.